// Code generated by protoc-gen-go.
// source: audio_control.proto
// DO NOT EDIT!

package hello

import proto "code.google.com/p/goprotobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

type AudioClassifierMessage_ClassifierType int32

const (
	AudioClassifierMessage_LINEARSVM AudioClassifierMessage_ClassifierType = 0
)

var AudioClassifierMessage_ClassifierType_name = map[int32]string{
	0: "LINEARSVM",
}
var AudioClassifierMessage_ClassifierType_value = map[string]int32{
	"LINEARSVM": 0,
}

func (x AudioClassifierMessage_ClassifierType) Enum() *AudioClassifierMessage_ClassifierType {
	p := new(AudioClassifierMessage_ClassifierType)
	*p = x
	return p
}
func (x AudioClassifierMessage_ClassifierType) String() string {
	return proto.EnumName(AudioClassifierMessage_ClassifierType_name, int32(x))
}
func (x AudioClassifierMessage_ClassifierType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *AudioClassifierMessage_ClassifierType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AudioClassifierMessage_ClassifierType_value, data, "AudioClassifierMessage_ClassifierType")
	if err != nil {
		return err
	}
	*x = AudioClassifierMessage_ClassifierType(value)
	return nil
}

type AudioControl_AudioCaptureAction int32

const (
	AudioControl_OFF AudioControl_AudioCaptureAction = 0
	AudioControl_ON  AudioControl_AudioCaptureAction = 1
)

var AudioControl_AudioCaptureAction_name = map[int32]string{
	0: "OFF",
	1: "ON",
}
var AudioControl_AudioCaptureAction_value = map[string]int32{
	"OFF": 0,
	"ON":  1,
}

func (x AudioControl_AudioCaptureAction) Enum() *AudioControl_AudioCaptureAction {
	p := new(AudioControl_AudioCaptureAction)
	*p = x
	return p
}
func (x AudioControl_AudioCaptureAction) String() string {
	return proto.EnumName(AudioControl_AudioCaptureAction_name, int32(x))
}
func (x AudioControl_AudioCaptureAction) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *AudioControl_AudioCaptureAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AudioControl_AudioCaptureAction_value, data, "AudioControl_AudioCaptureAction")
	if err != nil {
		return err
	}
	*x = AudioControl_AudioCaptureAction(value)
	return nil
}

type AudioClassifierMessage struct {
	Idata            []int32                                `protobuf:"zigzag32,1,rep,name=idata" json:"idata,omitempty"`
	Numclasses       *int32                                 `protobuf:"varint,2,opt,name=numclasses" json:"numclasses,omitempty"`
	Type             *AudioClassifierMessage_ClassifierType `protobuf:"varint,3,opt,name=type,enum=AudioClassifierMessage_ClassifierType" json:"type,omitempty"`
	XXX_unrecognized []byte                                 `json:"-"`
}

func (m *AudioClassifierMessage) Reset()         { *m = AudioClassifierMessage{} }
func (m *AudioClassifierMessage) String() string { return proto.CompactTextString(m) }
func (*AudioClassifierMessage) ProtoMessage()    {}

func (m *AudioClassifierMessage) GetIdata() []int32 {
	if m != nil {
		return m.Idata
	}
	return nil
}

func (m *AudioClassifierMessage) GetNumclasses() int32 {
	if m != nil && m.Numclasses != nil {
		return *m.Numclasses
	}
	return 0
}

func (m *AudioClassifierMessage) GetType() AudioClassifierMessage_ClassifierType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

type AudioControl struct {
	AudioMinEnergyThreshold                   *int32                           `protobuf:"varint,1,opt,name=audio_min_energy_threshold" json:"audio_min_energy_threshold,omitempty"`
	AudioNumFeatVecsUntilAttemptFeatureUpload *int32                           `protobuf:"varint,2,opt,name=audio_num_feat_vecs_until_attempt_feature_upload" json:"audio_num_feat_vecs_until_attempt_feature_upload,omitempty"`
	AudioFeatBufferSize                       *int32                           `protobuf:"varint,3,opt,name=audio_feat_buffer_size" json:"audio_feat_buffer_size,omitempty"`
	AudioRecordingPeriodInFrames              *int32                           `protobuf:"varint,4,opt,name=audio_recording_period_in_frames" json:"audio_recording_period_in_frames,omitempty"`
	AudioCaptureAction                        *AudioControl_AudioCaptureAction `protobuf:"varint,8,opt,name=audio_capture_action,enum=AudioControl_AudioCaptureAction" json:"audio_capture_action,omitempty"`
	AudioCaptureClassifier                    *AudioClassifierMessage          `protobuf:"bytes,9,opt,name=audio_capture_classifier" json:"audio_capture_classifier,omitempty"`
	AudioCaptureHmm                           *AudioClassifierMessage          `protobuf:"bytes,10,opt,name=audio_capture_hmm" json:"audio_capture_hmm,omitempty"`
	AudioSaveRawData                          *AudioControl_AudioCaptureAction `protobuf:"varint,11,opt,name=audio_save_raw_data,enum=AudioControl_AudioCaptureAction" json:"audio_save_raw_data,omitempty"`
	AudioSaveFeatures                         *AudioControl_AudioCaptureAction `protobuf:"varint,12,opt,name=audio_save_features,enum=AudioControl_AudioCaptureAction" json:"audio_save_features,omitempty"`
	XXX_unrecognized                          []byte                           `json:"-"`
}

func (m *AudioControl) Reset()         { *m = AudioControl{} }
func (m *AudioControl) String() string { return proto.CompactTextString(m) }
func (*AudioControl) ProtoMessage()    {}

func (m *AudioControl) GetAudioMinEnergyThreshold() int32 {
	if m != nil && m.AudioMinEnergyThreshold != nil {
		return *m.AudioMinEnergyThreshold
	}
	return 0
}

func (m *AudioControl) GetAudioNumFeatVecsUntilAttemptFeatureUpload() int32 {
	if m != nil && m.AudioNumFeatVecsUntilAttemptFeatureUpload != nil {
		return *m.AudioNumFeatVecsUntilAttemptFeatureUpload
	}
	return 0
}

func (m *AudioControl) GetAudioFeatBufferSize() int32 {
	if m != nil && m.AudioFeatBufferSize != nil {
		return *m.AudioFeatBufferSize
	}
	return 0
}

func (m *AudioControl) GetAudioRecordingPeriodInFrames() int32 {
	if m != nil && m.AudioRecordingPeriodInFrames != nil {
		return *m.AudioRecordingPeriodInFrames
	}
	return 0
}

func (m *AudioControl) GetAudioCaptureAction() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioCaptureAction != nil {
		return *m.AudioCaptureAction
	}
	return 0
}

func (m *AudioControl) GetAudioCaptureClassifier() *AudioClassifierMessage {
	if m != nil {
		return m.AudioCaptureClassifier
	}
	return nil
}

func (m *AudioControl) GetAudioCaptureHmm() *AudioClassifierMessage {
	if m != nil {
		return m.AudioCaptureHmm
	}
	return nil
}

func (m *AudioControl) GetAudioSaveRawData() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioSaveRawData != nil {
		return *m.AudioSaveRawData
	}
	return 0
}

func (m *AudioControl) GetAudioSaveFeatures() AudioControl_AudioCaptureAction {
	if m != nil && m.AudioSaveFeatures != nil {
		return *m.AudioSaveFeatures
	}
	return 0
}

func init() {
	proto.RegisterEnum("AudioClassifierMessage_ClassifierType", AudioClassifierMessage_ClassifierType_name, AudioClassifierMessage_ClassifierType_value)
	proto.RegisterEnum("AudioControl_AudioCaptureAction", AudioControl_AudioCaptureAction_name, AudioControl_AudioCaptureAction_value)
}
